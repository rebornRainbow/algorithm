#### p1

Tim需要为考试学习，但天气变暖，他想在外面呆的时间更长。当气温为$t$（整数）度以上时，Tim喜欢在外面的时间更多：在外面度过一天后，他的幸福感会增加$t$（当$t$为负数时幸福感会减少）。在考试前的$n$天里，Tim每天要么学习要么在外面玩耍（不会同时进行）。为了跟上课程，Tim决定不连续玩耍超过两天。给定未来$n$天的天气预报，描述一个$O(n)$时间复杂度的动态规划算法，以确定哪些天Tim应该学习，以增加他的幸福感



- 子问题:$RES[i]$表示从$[0\dots i]$这几天，最后一天一定外出或者不外出的情况下，获得的最大的幸福值



$$[ \dots,i-3(大前天),i-2(前天),i-1(昨天),i(今天),\dots,]$$

- 关系:
```c++
RES[i] = max{
今天不出去:
  RES[i-1],
今天出去
  昨天出去:前天必须不出去:
    T[i] + T[i-1] + RES[i-3],
  昨天不出去:
    T[i] + RES[i-2],
}
```
- 原问题:
RES[n-1]


- 拓扑序：
i在减少

- 基础情况:
所有小于0的索引值为0

- 时间：
$O(n)$



- 这是**错误的**想法

  这个需要设计一个数据结构

  维持一个数组
  每个数组的元素是:
  一个T_c:表示今天的温度

  一个H_m:表示可以获取的幸福值得最大值

  一个list,表示当前答案需要哪些天出去。




#### p2

操作系统Menix具有可以比较文件的diff实用程序。一个文件是一个字符串的有序序列，其中第$i$个字符串被称为文件的第$i$行。对文件进行的单个更改为：

将一个新行插入文件中；

从文件中删除单个行；

交换文件中相邻的两行。

在Menix中，交换两行的成本较低，因为它们已经在文件中，但插入或删除行的成本较高。从文件$A$到文件$B$的diff是任何一系列更改，当按顺序应用于$A$时，将其转换为$B$，其中任何一行最多只能交换一次，并且在$A$和$B$中交换的任何一对行都相邻。给定两个包含完全$n$行的文件$A$和$B$，描述一个$O(kn+n^2)$时间复杂度的算法，以返回从$A$到$B$的diff，最小化不是交换的更改数量，假设来自任何一个文件的任何行最多具有$k$个ASCII字符

简化：
有两个字符串序列，
可以插入，删除，交换，交换代价较小，问怎样的操作序列才能把当前的序列变为一样的。

$file1[0 \cdots i]$

$file2[0 \cdots j]$

子问题：
用子字串，m_change(i,j):表示把$file1[0 \cdots i]$变得和$file2[0 \cdots j]$一样所花的最小的代价。
m_change(i,j) = 
如果file[i] 和 file[j]相同
  m_change(i-1,j-1);
如果


#### p3

Saggie Mimpson是一个喜欢建造积木塔的幼儿。她的每个积木都是一个三维长方体，其中每个积木$b_i$具有正整数宽度$w_i$、高度$h_i$和长度$\ell_i$，并且她至少有三个每种类型的积木。每个积木可以被定向，使得它的任何对立面都可以作为它的顶部和底部面，而该定向下积木的高度是这些面之间的距离。Saggie想要通过堆叠她的积木尽可能高地构建一座塔，但是只有当积木$b_i$的底部尺寸严格小于积木$b_j$的顶部尺寸时，才能将定向的积木$b_i$叠放在另一个定向的积木$b_j$之上。给定她$n$个积木的尺寸，请描述一个$O(n^2)$时间复杂度的算法，以确定Saggie可以从她的积木中建造的最高塔的高度。

${ }^{1}$ 如果积木$b_i$的底部尺寸为$p\times q$，积木$b_j$的顶部尺寸为$s\times t$，则只有当$p<s$并且$q<t$或$p<t$并且$q<s$时，积木$b_i$可以在该定向上叠放在积木$b_j$上

<div style="page-break-after: always;"></div>
#### p4

公主梅露在数字化的鬼屋森林中收集蘑菇。这个森林是一个 $n \times n$ 的方格网格，每个网格包含树木、蘑菇或者是空的。公主梅露可以从一个格子移动到另一个格子，如果这两个格子共享一个边缘，但她不能进入包含树木的格子。公主梅露从左上方的网格出发，并希望通过一条快速的路径到达右下方的家 ${ }^{2}$。这个鬼屋森林很吓人，因此她希望通过一条快速路径到达家：从起点到家的路径经过最多 $2n-1$ 个网格（包括起点和终点）。如果公主梅露进入一个带有蘑菇的网格，她将捡起它。让 $k$ 成为她能够在任何一条快速路径上捡到的最大蘑菇数量，并且如果她能够在该路径上捡到 $k$ 个蘑菇，那么该快速路径是最优的。

(a) [15 分] 给定森林网格的地图，描述一个 $O\left(n^{2}\right)$ 的算法，返回该森林中通过快速路径到达终点的不同最优路径的数量，假设存在一条快速路径。

(b) [25 分] 编写一个 Python 函数 count_paths($F$)，它实现了您在(a)中的算法。

${ }^{2}$ 假设起点和终点的网格都是空的。 MIT OpenCourseWare